diff --git a/python-pkg/lirc/async_client.py b/python-pkg/lirc/async_client.py
index 1affce68..96c303d2 100644
--- a/python-pkg/lirc/async_client.py
+++ b/python-pkg/lirc/async_client.py
@@ -57,9 +57,13 @@ class AsyncConnection(object):
 
         def read_from_fd():
             ''' Read data from the connection fd and put into queue. '''
-            line = self._conn.readline(0)
-            if line:
-                asyncio.ensure_future(self._queue.put(line))
+            try:
+                line = self._conn.readline(0)
+                if line:
+                    asyncio.ensure_future(self._queue.put(line))
+            except Exception as e:
+                self.close()
+                self._queue.put_nowait(e)
 
         self._conn = connection
         self._loop = loop
@@ -72,7 +76,10 @@ class AsyncConnection(object):
 
     async def readline(self) -> str:
         ''' Asynchronous get next line from the connection. '''
-        return await self._queue.get()
+        line = await self._queue.get()
+        if isinstance(line, Exception):
+            raise line
+        return line
 
     def __aiter__(self):
         ''' Return async iterator. '''
@@ -80,7 +87,10 @@ class AsyncConnection(object):
 
     async def __anext__(self):
         ''' Implement async iterator.next(). '''
-        return await self._queue.get()
+        line = await self._queue.get()
+        if isinstance(line, Exception):
+            raise StopAsyncIteration
+        return line
 
     async def __aenter__(self):
         ''' Implement "async with". '''
diff --git a/python-pkg/lirc/client.py b/python-pkg/lirc/client.py
index 7e069a55..bf5955fb 100644
--- a/python-pkg/lirc/client.py
+++ b/python-pkg/lirc/client.py
@@ -229,7 +229,10 @@ class RawConnection(AbstractConnection):
                         "readline: no data within %f seconds" % timeout)
                 else:
                     return None
-            self._buffer += self._socket.recv(4096)
+            recv = self._socket.recv(4096)
+            if len(recv) == 0:
+                raise ConnectionResetError('Connection lost')
+            self._buffer += recv
         line, self._buffer = self._buffer.split(b'\n', 1)
         return line.decode('ascii', 'ignore')
 
diff --git a/python-pkg/tests/test_client.py b/python-pkg/tests/test_client.py
index d9af254d..cb47aa67 100644
--- a/python-pkg/tests/test_client.py
+++ b/python-pkg/tests/test_client.py
@@ -17,6 +17,10 @@ from lirc import RawConnection, LircdConnection, CommandConnection
 from lirc import AsyncConnection
 import lirc
 
+import signal
+from contextlib import contextmanager, suppress
+from concurrent.futures import TimeoutError
+
 _PACKET_ONE = '0123456789abcdef 00 KEY_1 mceusb'
 _LINE_0 = '0123456789abcdef 00 KEY_1 mceusb'
 _SOCKET = 'lircd.socket'
@@ -26,6 +30,43 @@ _EXPECT = subprocess.check_output('which expect', shell=True) \
     .decode('ascii').strip()
 
 
+class TimeoutException(Exception):
+    pass
+
+@contextmanager
+def event_loop(suppress=[]):
+
+    if isinstance(suppress, type) and issubclass(suppress, Exception):
+        suppress = [suppress]
+    elif isinstance(suppress, list):
+        for ex_type in suppress:
+            if not isinstance(ex_type, type) or not issubclass(ex_type, Exception):
+                raise ValueError('suppress is not an array of exception types')
+    else:
+        raise ValueError('suppress is not an exception type')
+
+    ex = []
+    def exception_handler(loop, context):
+        nonlocal ex
+        nonlocal suppress
+        for ex_type in suppress:
+            if isinstance(context['exception'], ex_type):
+                return
+        ex.append(context['exception'])
+
+    loop = asyncio.get_event_loop()
+    if loop.is_closed():
+        loop = asyncio.new_event_loop()
+        asyncio.set_event_loop(loop)
+    loop.set_exception_handler(exception_handler)
+
+    try:
+        yield loop
+    finally:
+        loop.close()
+        if len(ex):
+            raise Exception('Unhandled exceptions in async code') from ex[0]
+
 def _wait_for_socket():
     ''' Wait until the ncat process has setup the lircd.socket dummy. '''
     i = 0
@@ -39,6 +80,29 @@ def _wait_for_socket():
 class ReceiveTests(unittest.TestCase):
     ''' Test various Connections. '''
 
+    @contextmanager
+    def assertCompletedBeforeTimeout(self, timeout):
+
+        triggered = False
+
+        def handle_timeout(signum, frame):
+            nonlocal triggered
+            triggered = True
+            for task in asyncio.Task.all_tasks():
+                task.cancel()
+            raise TimeoutException()
+
+        try:
+            signal.signal(signal.SIGALRM, handle_timeout)
+            signal.alarm(timeout)
+            with suppress(TimeoutException, asyncio.CancelledError):
+                yield
+        finally:
+            signal.signal(signal.SIGALRM, signal.SIG_DFL)
+            signal.alarm(0)
+            if triggered:
+                raise self.failureException('Code block did not complete before the {} seconds timeout'.format(timeout)) from None
+
     def testReceiveOneRawLine(self):
         ''' Receive a single, raw line. '''
 
@@ -88,7 +152,7 @@ class ReceiveTests(unittest.TestCase):
     def testReceive1AsyncLines(self):
         ''' Receive 1000 lines using the async interface. '''
 
-        async def get_lines(raw_conn, count):
+        async def get_lines(raw_conn, count, loop):
 
             nonlocal lines
             async with AsyncConnection(raw_conn, loop) as conn:
@@ -106,12 +170,11 @@ class ReceiveTests(unittest.TestCase):
                               stdout = subprocess.PIPE,
                               stderr = subprocess.STDOUT) as child:
             _wait_for_socket()
-            loop = asyncio.get_event_loop()
             with LircdConnection('foo',
                                  socket_path=_SOCKET,
                                  lircrc_path='lircrc.conf') as conn:
-                loop.run_until_complete(get_lines(conn, 1000))
-            loop.close()
+                with event_loop() as loop:
+                    loop.run_until_complete(get_lines(conn, 1000, loop))
 
         self.assertEqual(len(lines), 1000)
         self.assertEqual(lines[0], 'foo-cmd')
@@ -130,6 +193,80 @@ class ReceiveTests(unittest.TestCase):
                                  lircrc_path='lircrc.conf') as conn:
                 self.assertRaises(lirc.TimeoutException, conn.readline, 0.1)
 
+    def testReceiveDisconnect(self):
+        ''' Generate a ConnectionResetError if connection is lost '''
+
+        if os.path.exists(_SOCKET):
+            os.unlink(_SOCKET)
+        cmd = [_SOCAT, 'UNIX-LISTEN:' + _SOCKET, 'EXEC:"sleep 1"']
+        with subprocess.Popen(cmd) as child:
+            _wait_for_socket()
+            with LircdConnection('foo',
+                                 socket_path=_SOCKET,
+                                 lircrc_path='lircrc.conf') as conn:
+                with self.assertRaises(ConnectionResetError):
+                    with self.assertCompletedBeforeTimeout(3):
+                        conn.readline(2)
+
+    def testReceiveAsyncDisconnectDontBlock(self):
+        ''' Do not block the loop if connection is lost '''
+
+        async def readline(raw_conn):
+            async with AsyncConnection(raw_conn, loop) as conn:
+                return await conn.readline()
+
+        if os.path.exists(_SOCKET):
+            os.unlink(_SOCKET)
+        cmd = [_SOCAT, 'UNIX-LISTEN:' + _SOCKET, 'EXEC:"sleep 1"']
+        with subprocess.Popen(cmd) as child:
+            _wait_for_socket()
+            with LircdConnection('foo',
+                                 socket_path=_SOCKET,
+                                 lircrc_path='lircrc.conf') as conn:
+                with event_loop(suppress=[ConnectionResetError, TimeoutException]) as loop:
+                    with self.assertCompletedBeforeTimeout(3):
+                        with suppress(TimeoutError, ConnectionResetError):
+                            loop.run_until_complete(asyncio.wait_for(readline(conn), 2))
+
+    def testReceiveAsyncExceptionReraises(self):
+        ''' Async readline should reraise if an exception occurs during select loop '''
+
+        async def readline(raw_conn):
+            async with AsyncConnection(raw_conn, loop) as conn:
+                return await conn.readline()
+
+        if os.path.exists(_SOCKET):
+            os.unlink(_SOCKET)
+        cmd = [_SOCAT, 'UNIX-LISTEN:' + _SOCKET, 'EXEC:"sleep 1"']
+        with subprocess.Popen(cmd) as child:
+            _wait_for_socket()
+            with LircdConnection('foo',
+                                 socket_path=_SOCKET,
+                                 lircrc_path='lircrc.conf') as conn:
+                with event_loop(suppress=[ConnectionResetError, TimeoutException]) as loop:
+                    with self.assertCompletedBeforeTimeout(2):
+                        with self.assertRaises(ConnectionResetError):
+                            loop.run_until_complete(readline(conn))
+
+    def testReceiveAsyncExceptionEndsIterator(self):
+        ''' Async iterator should stop if an exception occurs in the select loop '''
+
+        async def get_lines(raw_conn):
+            async with AsyncConnection(raw_conn, loop) as conn:
+                async for keypress in conn:
+                    pass
+
+        if os.path.exists(_SOCKET):
+            os.unlink(_SOCKET)
+        cmd = [_SOCAT, 'UNIX-LISTEN:' + _SOCKET, 'EXEC:"sleep 1"']
+        with subprocess.Popen(cmd) as child:
+            _wait_for_socket()
+            with LircdConnection('foo',
+                                 socket_path=_SOCKET,
+                                 lircrc_path='lircrc.conf') as conn:
+                with event_loop(suppress=[ConnectionResetError, TimeoutException]) as loop:
+                    with self.assertCompletedBeforeTimeout(2):
+                        self.assertIsNone(loop.run_until_complete(get_lines(conn)))
 
 class CommandTests(unittest.TestCase):
     ''' Test Command, Reply, ReplyParser and some Commands samples. '''
